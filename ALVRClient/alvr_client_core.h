/* ALVR is licensed under the MIT license. https://github.com/alvr-org/ALVR/blob/master/LICENSE */

#pragma once

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

enum AlvrCodec
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
    ALVR_CODEC_H264 = 0,
    ALVR_CODEC_HEVC = 1,
    ALVR_CODEC_AV1 = 2,
};
#ifndef __cplusplus
typedef uint8_t AlvrCodec;
#endif // __cplusplus

typedef enum AlvrLogLevel {
    ALVR_LOG_LEVEL_ERROR,
    ALVR_LOG_LEVEL_WARN,
    ALVR_LOG_LEVEL_INFO,
    ALVR_LOG_LEVEL_DEBUG,
} AlvrLogLevel;

enum AlvrEvent_Tag
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
    ALVR_EVENT_HUD_MESSAGE_UPDATED,
    ALVR_EVENT_STREAMING_STARTED,
    ALVR_EVENT_STREAMING_STOPPED,
    ALVR_EVENT_HAPTICS,
    ALVR_EVENT_CREATE_DECODER,
    ALVR_EVENT_FRAME_READY,
};
#ifndef __cplusplus
typedef uint8_t AlvrEvent_Tag;
#endif // __cplusplus

typedef struct StreamingStarted_Body {
    AlvrEvent_Tag tag;
    uint32_t view_width;
    uint32_t view_height;
    float refresh_rate_hint;
    bool enable_foveation;
    float foveation_center_size_x;
    float foveation_center_size_y;
    float foveation_center_shift_x;
    float foveation_center_shift_y;
    float foveation_edge_ratio_x;
    float foveation_edge_ratio_y;
} StreamingStarted_Body;

typedef struct Haptics_Body {
    AlvrEvent_Tag tag;
    uint64_t device_id;
    float duration_s;
    float frequency;
    float amplitude;
} Haptics_Body;

typedef struct CreateDecoder_Body {
    AlvrEvent_Tag tag;
    AlvrCodec codec;
} CreateDecoder_Body;

typedef union AlvrEvent {
    AlvrEvent_Tag tag;
    StreamingStarted_Body STREAMING_STARTED;
    Haptics_Body HAPTICS;
    CreateDecoder_Body CREATE_DECODER;
} AlvrEvent;

typedef struct AlvrFov {
    float left;
    float right;
    float up;
    float down;
} AlvrFov;

typedef enum AlvrButtonValue_Tag {
    ALVR_BUTTON_VALUE_BINARY,
    ALVR_BUTTON_VALUE_SCALAR,
} AlvrButtonValue_Tag;

typedef struct AlvrButtonValue {
    AlvrButtonValue_Tag tag;
    union {
        struct {
            bool binary;
        };
        struct {
            float scalar;
        };
    };
} AlvrButtonValue;

typedef struct AlvrQuat {
    float x;
    float y;
    float z;
    float w;
} AlvrQuat;

typedef struct AlvrDeviceMotion {
    uint64_t device_id;
    struct AlvrQuat orientation;
    float position[3];
    float linear_velocity[3];
    float angular_velocity[3];
} AlvrDeviceMotion;

typedef struct AlvrStreamConfig {
    uint32_t view_resolution_width;
    uint32_t view_resolution_height;
    const uint32_t **swapchain_textures;
    uint32_t swapchain_length;
    bool enable_foveation;
    float foveation_center_size_x;
    float foveation_center_size_y;
    float foveation_center_shift_x;
    float foveation_center_shift_y;
    float foveation_edge_ratio_x;
    float foveation_edge_ratio_y;
} AlvrStreamConfig;

typedef struct AlvrViewInput {
    struct AlvrQuat orientation;
    float position[3];
    struct AlvrFov fov;
    uint32_t swapchain_index;
} AlvrViewInput;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

uint64_t alvr_path_string_to_id(const char *path);

void alvr_log(enum AlvrLogLevel level, const char *message);

void alvr_log_time(const char *tag);

// On non-Android platforms, java_vm and constext should be null.
// NB: context must be thread safe.
void alvr_initialize(void *java_vm,
                     void *context,
                     uint32_t recommended_view_width,
                     uint32_t recommended_view_height,
                     const float *refresh_rates,
                     int32_t refresh_rates_count,
                     bool external_decoder);

void alvr_destroy(void);

void alvr_resume(void);

void alvr_pause(void);

// Returns true if there was a new event
bool alvr_poll_event(union AlvrEvent *out_event);

// Call only with external decoder
// Returns the number of bytes of the next nal, or 0 if there are no nals ready.
// If out_nal or out_timestamp_ns is null, no nal is dequeued. Use to get the nal allocation size.
// Returns out_timestamp_ns == 0 if config NAL.
uint64_t alvr_poll_nal(char *out_nal, uint64_t *out_timestamp_ns);

uint64_t alvr_hud_message(char *message_buffer);

void alvr_send_views_config(const struct AlvrFov *fov, float ipd_m);

void alvr_send_battery(uint64_t device_id, float gauge_value, bool is_plugged);

void alvr_send_playspace(float width, float height);

void alvr_send_button(uint64_t path_id, struct AlvrButtonValue value);

void alvr_send_tracking(uint64_t target_timestamp_ns,
                        const struct AlvrDeviceMotion *device_motions,
                        uint64_t device_motions_count);

uint64_t alvr_get_head_prediction_offset_ns(void);

uint64_t alvr_get_tracker_prediction_offset_ns(void);

void alvr_report_submit(uint64_t target_timestamp_ns, uint64_t vsync_queue_ns);

// Call only with external decoder
void alvr_request_idr(void);

// Call only with external decoder
void alvr_report_frame_decoded(uint64_t target_timestamp_ns);

// Call only with external decoder
void alvr_report_compositor_start(uint64_t target_timestamp_ns);

// Call only with internal decoder (Android only)
// Returns frame timestamp in nanoseconds or -1 if no frame available. Returns an AHardwareBuffer
// from out_buffer.
int64_t alvr_get_frame(void **out_buffer);

void alvr_initialize_opengl(void);

void alvr_destroy_opengl(void);

void alvr_resume_opengl(uint32_t preferred_view_width,
                        uint32_t preferred_view_height,
                        const uint32_t **swapchain_textures,
                        uint32_t swapchain_length);

void alvr_pause_opengl(void);

void alvr_update_hud_message_opengl(const char *message);

void alvr_start_stream_opengl(struct AlvrStreamConfig config);

void alvr_render_lobby_opengl(const struct AlvrViewInput *view_inputs);

void alvr_render_stream_opengl(void *hardware_buffer, const uint32_t *swapchain_indices);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus
